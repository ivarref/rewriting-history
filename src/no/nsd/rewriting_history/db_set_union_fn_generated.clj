(ns no.nsd.rewriting-history.db-set-union-fn-generated)

(def datomic-fn-def
  (clojure.edn/read-string
    {:readers {'db/id  datomic.db/id-literal
               'db/fn  datomic.function/construct
               'base64 datomic.codec/base-64-literal}}
    "{:db/ident :set/union\n :db/fn #db/fn \n{:lang \"clojure\", :requires [[clojure.walk :as walk] [clojure.tools.logging :as log] [datomic.api :as d] [clojure.set :as set]], :imports [(java.util UUID HashSet List) (datomic Database)], :params [db lookup-ref attr values], :code (letfn [(to-clojure-types [m] (do (walk/prewalk (fn [e] (cond (instance? HashSet e) (into #{} e) (and (instance? List e) (not (vector? e))) (vec e) :else e)) m))) (rand-id [] (do (str \"id-\" (UUID/randomUUID)))) (set-union-ref [db [id-a id-v] attr values] (do (let [e (d/q (quote [:find ?e . :in $ ?a ?v :where [?e ?a ?v]]) db id-a id-v) curr-set (when e (into #{} (d/q (quote [:find [(pull ?v [*]) ...] :in $ ?e ?a :where [?e ?a ?v]]) db e attr))) curr-set-without-eid (into #{} (mapv (fn [ent] (with-meta (dissoc ent :db/id) #:db{:id (:db/id ent)})) curr-set)) dbid (rand-id) to-add (->> (set/difference values curr-set-without-eid) (mapv (fn [e] (with-meta e {:tempid (or (:db/id e) (rand-id))}))) (sort-by (fn [e] (pr-str (into (sorted-map) e))))) tx (vec (concat [{id-a id-v, :db/id dbid}] (mapv (fn [add] (merge #:db{:id (->> add (meta) :tempid)} add)) to-add) (mapv (fn [add] [:db/add dbid attr (->> add (meta) :tempid)]) to-add)))] tx))) (set-union-primitives [db [id-a id-v] attr values] (do [{id-a id-v, attr values}]))] (do (let [values (to-clojure-types values) lookup-ref (to-clojure-types lookup-ref) _ (assert (vector? lookup-ref)) _ (assert (set? values)) _ (assert (keyword? attr)) db (if (instance? Database db) db (d/db db)) is-ref? (= :db.type/ref (d/q (quote [:find ?type . :in $ ?attr :where [?attr :db/valueType ?t] [?t :db/ident ?type]]) db attr))] (when is-ref? (doseq [v values] (assert (map? v) \"expected set element to be a map\"))) (doseq [v values] (when (and (map? v) (some? (:db/id v)) (not (string? (:db/id v)))) (throw (ex-info \"expected :db/id to be a string or not present\" {:element v})))) (if is-ref? (set-union-ref db lookup-ref attr values) (set-union-primitives db lookup-ref attr values)))))}\n}"))